

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>networkx.algorithms.dag &mdash; NetworkX 2.2rc1.dev20180425145258 documentation</title>
  

  
  
  
  

  

  
  
    
      <link rel="search" type="application/opensearchdescription+xml"
            title="Search within NetworkX 2.2rc1.dev20180425145258 documentation"
            href="../../../_static/opensearch.xml"/>
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> NetworkX
          

          
          </a>

          
            
            
              <div class="version">
                2.2rc1.dev_20180425145258
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Examples</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NetworkX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>networkx.algorithms.dag</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for networkx.algorithms.dag</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#    Copyright (C) 2006-2018 by</span>
<span class="c1">#    Aric Hagberg &lt;hagberg@lanl.gov&gt;</span>
<span class="c1">#    Dan Schult &lt;dschult@colgate.edu&gt;</span>
<span class="c1">#    Pieter Swart &lt;swart@lanl.gov&gt;</span>
<span class="c1">#    All rights reserved.</span>
<span class="c1">#    BSD license.</span>
<span class="c1">#</span>
<span class="c1"># Authors:</span>
<span class="c1">#    Aric Hagberg &lt;aric.hagberg@gmail.com&gt;</span>
<span class="c1">#    Dan Schult &lt;dschult@colgate.edu&gt;</span>
<span class="c1">#    Ben Edwards &lt;bedwards@cs.unm.edu&gt;</span>
<span class="c1">#    Neil Girdhar &lt;neil.girdhar@mcgill.ca&gt;</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;Algorithms for directed acyclic graphs (DAGs).</span>

<span class="sd">Note that most of these functions are only guaranteed to work for DAGs.</span>
<span class="sd">In general, these functions do not check for acyclic-ness, so it is up</span>
<span class="sd">to the user to check for that.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">starmap</span>
<span class="kn">import</span> <span class="nn">heapq</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.generators.trees</span> <span class="k">import</span> <span class="n">NIL</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="k">import</span> <span class="n">arbitrary_element</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="k">import</span> <span class="n">consume</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="k">import</span> <span class="n">pairwise</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="k">import</span> <span class="n">generate_unique_node</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="k">import</span> <span class="n">not_implemented_for</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;descendants&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ancestors&#39;</span><span class="p">,</span>
           <span class="s1">&#39;topological_sort&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lexicographical_topological_sort&#39;</span><span class="p">,</span>
           <span class="s1">&#39;is_directed_acyclic_graph&#39;</span><span class="p">,</span>
           <span class="s1">&#39;is_aperiodic&#39;</span><span class="p">,</span>
           <span class="s1">&#39;transitive_closure&#39;</span><span class="p">,</span>
           <span class="s1">&#39;transitive_reduction&#39;</span><span class="p">,</span>
           <span class="s1">&#39;antichains&#39;</span><span class="p">,</span>
           <span class="s1">&#39;dag_longest_path&#39;</span><span class="p">,</span>
           <span class="s1">&#39;dag_longest_path_length&#39;</span><span class="p">,</span>
           <span class="s1">&#39;dag_to_branching&#39;</span><span class="p">]</span>

<span class="n">chaini</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span>


<div class="viewcode-block" id="descendants"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.descendants.html#networkx.algorithms.dag.descendants">[docs]</a><span class="k">def</span> <span class="nf">descendants</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return all nodes reachable from `source` in `G`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX DiGraph</span>
<span class="sd">        A directed acyclic graph (DAG)</span>
<span class="sd">    source : node in `G`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    set()</span>
<span class="sd">        The descendants of `source` in `G`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;The node </span><span class="si">%s</span><span class="s2"> is not in the graph.&quot;</span> <span class="o">%</span> <span class="n">source</span><span class="p">)</span>
    <span class="n">des</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">des</span> <span class="o">-</span> <span class="p">{</span><span class="n">source</span><span class="p">}</span></div>


<div class="viewcode-block" id="ancestors"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.ancestors.html#networkx.algorithms.dag.ancestors">[docs]</a><span class="k">def</span> <span class="nf">ancestors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return all nodes having a path to `source` in `G`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX DiGraph</span>
<span class="sd">        A directed acyclic graph (DAG)</span>
<span class="sd">    source : node in `G`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    set()</span>
<span class="sd">        The ancestors of source in G</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;The node </span><span class="si">%s</span><span class="s2"> is not in the graph.&quot;</span> <span class="o">%</span> <span class="n">source</span><span class="p">)</span>
    <span class="n">anc</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">source</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">anc</span> <span class="o">-</span> <span class="p">{</span><span class="n">source</span><span class="p">}</span></div>


<span class="k">def</span> <span class="nf">has_cycle</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decides whether the directed graph has a cycle.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">consume</span><span class="p">(</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="is_directed_acyclic_graph"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.is_directed_acyclic_graph.html#networkx.algorithms.dag.is_directed_acyclic_graph">[docs]</a><span class="k">def</span> <span class="nf">is_directed_acyclic_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if the graph `G` is a directed acyclic graph (DAG) or</span>
<span class="sd">    False if not.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        True if `G` is a DAG, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_cycle</span><span class="p">(</span><span class="n">G</span><span class="p">)</span></div>


<div class="viewcode-block" id="topological_sort"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.topological_sort.html#networkx.algorithms.dag.topological_sort">[docs]</a><span class="k">def</span> <span class="nf">topological_sort</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a generator of nodes in topologically sorted order.</span>

<span class="sd">    A topological sort is a nonunique permutation of the nodes such that an</span>
<span class="sd">    edge from u to v implies that u appears before v in the topological sort</span>
<span class="sd">    order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX digraph</span>
<span class="sd">        A directed acyclic graph (DAG)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iterable</span>
<span class="sd">        An iterable of node names in topological sorted order.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        Topological sort is defined for directed graphs only. If the graph `G`</span>
<span class="sd">        is undirected, a :exc:`NetworkXError` is raised.</span>

<span class="sd">    NetworkXUnfeasible</span>
<span class="sd">        If `G` is not a directed acyclic graph (DAG) no topological sort exists</span>
<span class="sd">        and a :exc:`NetworkXUnfeasible` exception is raised.  This can also be</span>
<span class="sd">        raised if `G` is changed while the returned iterator is being processed.</span>

<span class="sd">    RuntimeError</span>
<span class="sd">        If `G` is changed while the returned iterator is being processed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To get the reverse order of the topological sort:</span>

<span class="sd">    &gt;&gt;&gt; DG = nx.DiGraph([(1, 2), (2, 3)])</span>
<span class="sd">    &gt;&gt;&gt; list(reversed(list(nx.topological_sort(DG))))</span>
<span class="sd">    [3, 2, 1]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This algorithm is based on a description and proof in</span>
<span class="sd">    &quot;Introduction to Algorithms: A Creative Approach&quot; [1]_ .</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    is_directed_acyclic_graph, lexicographical_topological_sort</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Manber, U. (1989).</span>
<span class="sd">       *Introduction to Algorithms - A Creative Approach.* Addison-Wesley.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="s2">&quot;Topological sort not defined on undirected graphs.&quot;</span><span class="p">)</span>

    <span class="n">indegree_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">d</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
    <span class="c1"># These nodes have zero indegree and ready to be returned.</span>
    <span class="n">zero_indegree</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">zero_indegree</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">zero_indegree</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Graph changed during iteration&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">indegree_map</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Graph changed during iteration&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indegree_map</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">zero_indegree</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">indegree_map</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>

        <span class="k">yield</span> <span class="n">node</span>

    <span class="k">if</span> <span class="n">indegree_map</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">(</span><span class="s2">&quot;Graph contains a cycle or graph changed &quot;</span>
                                    <span class="s2">&quot;during iteration&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="lexicographical_topological_sort"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.lexicographical_topological_sort.html#networkx.algorithms.dag.lexicographical_topological_sort">[docs]</a><span class="k">def</span> <span class="nf">lexicographical_topological_sort</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a generator of nodes in lexicographically topologically sorted</span>
<span class="sd">    order.</span>

<span class="sd">    A topological sort is a nonunique permutation of the nodes such that an</span>
<span class="sd">    edge from u to v implies that u appears before v in the topological sort</span>
<span class="sd">    order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX digraph</span>
<span class="sd">        A directed acyclic graph (DAG)</span>

<span class="sd">    key : function, optional</span>
<span class="sd">        This function maps nodes to keys with which to resolve ambiguities in</span>
<span class="sd">        the sort order.  Defaults to the identity function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iterable</span>
<span class="sd">        An iterable of node names in lexicographical topological sort order.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        Topological sort is defined for directed graphs only. If the graph `G`</span>
<span class="sd">        is undirected, a :exc:`NetworkXError` is raised.</span>

<span class="sd">    NetworkXUnfeasible</span>
<span class="sd">        If `G` is not a directed acyclic graph (DAG) no topological sort exists</span>
<span class="sd">        and a :exc:`NetworkXUnfeasible` exception is raised.  This can also be</span>
<span class="sd">        raised if `G` is changed while the returned iterator is being processed.</span>

<span class="sd">    RuntimeError</span>
<span class="sd">        If `G` is changed while the returned iterator is being processed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This algorithm is based on a description and proof in</span>
<span class="sd">    &quot;Introduction to Algorithms: A Creative Approach&quot; [1]_ .</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    topological_sort</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Manber, U. (1989).</span>
<span class="sd">       *Introduction to Algorithms - A Creative Approach.* Addison-Wesley.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="s2">&quot;Topological sort not defined on undirected graphs.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">create_tuple</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">node</span>

    <span class="n">indegree_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">d</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
    <span class="c1"># These nodes have zero indegree and ready to be returned.</span>
    <span class="n">zero_indegree</span> <span class="o">=</span> <span class="p">[</span><span class="n">create_tuple</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">zero_indegree</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">zero_indegree</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">zero_indegree</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Graph changed during iteration&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">indegree_map</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Graph changed during iteration&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indegree_map</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">zero_indegree</span><span class="p">,</span> <span class="n">create_tuple</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
                <span class="k">del</span> <span class="n">indegree_map</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>

        <span class="k">yield</span> <span class="n">node</span>

    <span class="k">if</span> <span class="n">indegree_map</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXUnfeasible</span><span class="p">(</span><span class="s2">&quot;Graph contains a cycle or graph changed &quot;</span>
                                    <span class="s2">&quot;during iteration&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_aperiodic"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.is_aperiodic.html#networkx.algorithms.dag.is_aperiodic">[docs]</a><span class="k">def</span> <span class="nf">is_aperiodic</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if `G` is aperiodic.</span>

<span class="sd">    A directed graph is aperiodic if there is no integer k &gt; 1 that</span>
<span class="sd">    divides the length of every cycle in the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX DiGraph</span>
<span class="sd">        A directed graph</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        True if the graph is aperiodic False otherwise</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        If `G` is not directed</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This uses the method outlined in [1]_, which runs in $O(m)$ time</span>
<span class="sd">    given $m$ edges in `G`. Note that a graph is not aperiodic if it is</span>
<span class="sd">    acyclic as every integer trivial divides length 0 cycles.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Jarvis, J. P.; Shier, D. R. (1996),</span>
<span class="sd">       &quot;Graph-theoretic analysis of finite Markov chains,&quot;</span>
<span class="sd">       in Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:</span>
<span class="sd">       A Multidisciplinary Approach, CRC Press.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="s2">&quot;is_aperiodic not defined for undirected graphs&quot;</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">arbitrary_element</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">levels</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">this_level</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">this_level</span><span class="p">:</span>
        <span class="n">next_level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">this_level</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">levels</span><span class="p">:</span>  <span class="c1"># Non-Tree Edge</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">levels</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="n">levels</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Tree Edge</span>
                    <span class="n">next_level</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">levels</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>
        <span class="n">this_level</span> <span class="o">=</span> <span class="n">next_level</span>
        <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>  <span class="c1"># All nodes in tree</span>
        <span class="k">return</span> <span class="n">g</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_aperiodic</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">levels</span><span class="p">)))</span></div>


<div class="viewcode-block" id="transitive_closure"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.transitive_closure.html#networkx.algorithms.dag.transitive_closure">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;undirected&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transitive_closure</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns transitive closure of a directed graph</span>

<span class="sd">    The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that</span>
<span class="sd">    for all v,w in V there is an edge (v,w) in E+ if and only if there</span>
<span class="sd">    is a non-null path from v to w in G.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX DiGraph</span>
<span class="sd">        A directed graph</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NetworkX DiGraph</span>
<span class="sd">        The transitive closure of `G`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXNotImplemented</span>
<span class="sd">        If `G` is not directed</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] http://www.ics.uci.edu/~eppstein/PADS/PartialOrder.py</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TC</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
                          <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TC</span></div>


<div class="viewcode-block" id="transitive_reduction"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.transitive_reduction.html#networkx.algorithms.dag.transitive_reduction">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;undirected&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transitive_reduction</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns transitive reduction of a directed graph</span>

<span class="sd">    The transitive reduction of G = (V,E) is a graph G- = (V,E-) such that</span>
<span class="sd">    for all v,w in V there is an edge (v,w) in E- if and only if (v,w) is</span>
<span class="sd">    in E and there is no path from v to w in G with length greater than 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX DiGraph</span>
<span class="sd">        A directed acyclic graph (DAG)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NetworkX DiGraph</span>
<span class="sd">        The transitive reduction of `G`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        If `G` is not a directed acyclic graph (DAG) transitive reduction is</span>
<span class="sd">        not uniquely defined and a :exc:`NetworkXError` exception is raised.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    https://en.wikipedia.org/wiki/Transitive_reduction</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_directed_acyclic_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="s2">&quot;Transitive reduction only uniquely defined on directed acyclic graphs.&quot;</span><span class="p">)</span>
    <span class="n">TR</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">TR</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="n">u_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">u_edges</span> <span class="o">-=</span> <span class="p">{</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">dfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span>
        <span class="n">TR</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u_edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TR</span></div>


<div class="viewcode-block" id="antichains"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.antichains.html#networkx.algorithms.dag.antichains">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;undirected&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">antichains</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates antichains from a directed acyclic graph (DAG).</span>

<span class="sd">    An antichain is a subset of a partially ordered set such that any</span>
<span class="sd">    two elements in the subset are incomparable.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX DiGraph</span>
<span class="sd">        A directed acyclic graph (DAG)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    generator object</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXNotImplemented</span>
<span class="sd">        If `G` is not directed</span>

<span class="sd">    NetworkXUnfeasible</span>
<span class="sd">        If `G` contains a cycle</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function was originally developed by Peter Jipsen and Franco Saliola</span>
<span class="sd">    for the SAGE project. It&#39;s included in NetworkX with permission from the</span>
<span class="sd">    authors. Original SAGE code at:</span>

<span class="sd">    https://github.com/sagemath/sage/blob/master/src/sage/combinat/posets/hasse_diagram.py</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Free Lattices, by R. Freese, J. Jezek and J. B. Nation,</span>
<span class="sd">       AMS, Vol 42, 1995, p. 226.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TC</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">antichains_stacks</span> <span class="o">=</span> <span class="p">[([],</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">G</span><span class="p">)))))]</span>
    <span class="k">while</span> <span class="n">antichains_stacks</span><span class="p">:</span>
        <span class="p">(</span><span class="n">antichain</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span> <span class="o">=</span> <span class="n">antichains_stacks</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># Invariant:</span>
        <span class="c1">#  - the elements of antichain are independent</span>
        <span class="c1">#  - the elements of stack are independent from those of antichain</span>
        <span class="k">yield</span> <span class="n">antichain</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">new_antichain</span> <span class="o">=</span> <span class="n">antichain</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="n">new_stack</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">stack</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">t</span> <span class="ow">in</span> <span class="n">TC</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">TC</span><span class="p">[</span><span class="n">t</span><span class="p">]))]</span>
            <span class="n">antichains_stacks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_antichain</span><span class="p">,</span> <span class="n">new_stack</span><span class="p">))</span></div>


<div class="viewcode-block" id="dag_longest_path"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.dag_longest_path.html#networkx.algorithms.dag.dag_longest_path">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;undirected&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dag_longest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the longest path in a directed acyclic graph (DAG).</span>

<span class="sd">    If `G` has edges with `weight` attribute the edge data are used as</span>
<span class="sd">    weight values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX DiGraph</span>
<span class="sd">        A directed acyclic graph (DAG)</span>

<span class="sd">    weight : str, optional</span>
<span class="sd">        Edge data key to use for weight</span>

<span class="sd">    default_weight : int, optional</span>
<span class="sd">        The weight of edges that do not have a weight attribute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        Longest path</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXNotImplemented</span>
<span class="sd">        If `G` is not directed</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    dag_longest_path_length</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># stores {v : (length, u)}</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">us</span> <span class="o">=</span> <span class="p">[(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">default_weight</span><span class="p">),</span> <span class="n">u</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">pred</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="c1"># Use the best predecessor if there is one and its distance is</span>
        <span class="c1"># non-negative, otherwise terminate.</span>
        <span class="n">maxu</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">us</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">us</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxu</span> <span class="k">if</span> <span class="n">maxu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">v</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dist</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">path</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">path</span></div>


<div class="viewcode-block" id="dag_longest_path_length"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.dag_longest_path_length.html#networkx.algorithms.dag.dag_longest_path_length">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;undirected&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dag_longest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the longest path length in a DAG</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX DiGraph</span>
<span class="sd">        A directed acyclic graph (DAG)</span>

<span class="sd">    weight : string, optional</span>
<span class="sd">        Edge data key to use for weight</span>

<span class="sd">    default_weight : int, optional</span>
<span class="sd">        The weight of edges that do not have a weight attribute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Longest path length</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXNotImplemented</span>
<span class="sd">        If `G` is not directed</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    dag_longest_path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dag_longest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">default_weight</span><span class="p">)</span>
    <span class="n">path_length</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairwise</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="n">path_length</span> <span class="o">+=</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">default_weight</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">path_length</span></div>


<span class="k">def</span> <span class="nf">root_to_leaf_paths</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Yields root-to-leaf paths in a directed acyclic graph.</span>

<span class="sd">    `G` must be a directed acyclic graph. If not, the behavior of this</span>
<span class="sd">    function is undefined. A &quot;root&quot; in this graph is a node of in-degree</span>
<span class="sd">    zero and a &quot;leaf&quot; a node of out-degree zero.</span>

<span class="sd">    When invoked, this function iterates over each path from any root to</span>
<span class="sd">    any leaf. A path is a list of nodes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">leaves</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">all_paths</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
    <span class="c1"># TODO In Python 3, this would be better as `yield from ...`.</span>
    <span class="k">return</span> <span class="n">chaini</span><span class="p">(</span><span class="n">starmap</span><span class="p">(</span><span class="n">all_paths</span><span class="p">,</span> <span class="n">product</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">leaves</span><span class="p">)))</span>


<div class="viewcode-block" id="dag_to_branching"><a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.dag.dag_to_branching.html#networkx.algorithms.dag.dag_to_branching">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;multigraph&#39;</span><span class="p">)</span>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;undirected&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dag_to_branching</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a branching representing all (overlapping) paths from</span>
<span class="sd">    root nodes to leaf nodes in the given directed acyclic graph.</span>

<span class="sd">    As described in :mod:`networkx.algorithms.tree.recognition`, a</span>
<span class="sd">    *branching* is a directed forest in which each node has at most one</span>
<span class="sd">    parent. In other words, a branching is a disjoint union of</span>
<span class="sd">    *arborescences*. For this function, each node of in-degree zero in</span>
<span class="sd">    `G` becomes a root of one of the arborescences, and there will be</span>
<span class="sd">    one leaf node for each distinct path from that root to a leaf node</span>
<span class="sd">    in `G`.</span>

<span class="sd">    Each node `v` in `G` with *k* parents becomes *k* distinct nodes in</span>
<span class="sd">    the returned branching, one for each parent, and the sub-DAG rooted</span>
<span class="sd">    at `v` is duplicated for each copy. The algorithm then recurses on</span>
<span class="sd">    the children of each copy of `v`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        A directed acyclic graph.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DiGraph</span>
<span class="sd">        The branching in which there is a bijection between root-to-leaf</span>
<span class="sd">        paths in `G` (in which multiple paths may share the same leaf)</span>
<span class="sd">        and root-to-leaf paths in the branching (in which there is a</span>
<span class="sd">        unique path from a root to a leaf).</span>

<span class="sd">        Each node has an attribute &#39;source&#39; whose value is the original</span>
<span class="sd">        node to which this node corresponds. No other graph, node, or</span>
<span class="sd">        edge attributes are copied into this new graph.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXNotImplemented</span>
<span class="sd">        If `G` is not directed, or if `G` is a multigraph.</span>

<span class="sd">    HasACycle</span>
<span class="sd">        If `G` is not acyclic.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To examine which nodes in the returned branching were produced by</span>
<span class="sd">    which original node in the directed acyclic graph, we can collect</span>
<span class="sd">    the mapping from source node to new nodes into a dictionary. For</span>
<span class="sd">    example, consider the directed diamond graph::</span>

<span class="sd">        &gt;&gt;&gt; from collections import defaultdict</span>
<span class="sd">        &gt;&gt;&gt; from operator import itemgetter</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; G = nx.DiGraph(nx.utils.pairwise(&#39;abd&#39;))</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from(nx.utils.pairwise(&#39;acd&#39;))</span>
<span class="sd">        &gt;&gt;&gt; B = nx.dag_to_branching(G)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; sources = defaultdict(set)</span>
<span class="sd">        &gt;&gt;&gt; for v, source in B.nodes(data=&#39;source&#39;):</span>
<span class="sd">        ...     sources[source].add(v)</span>
<span class="sd">        &gt;&gt;&gt; len(sources[&#39;a&#39;])</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; len(sources[&#39;d&#39;])</span>
<span class="sd">        2</span>

<span class="sd">    To copy node attributes from the original graph to the new graph,</span>
<span class="sd">    you can use a dictionary like the one constructed in the above</span>
<span class="sd">    example::</span>

<span class="sd">        &gt;&gt;&gt; for source, nodes in sources.items():</span>
<span class="sd">        ...     for v in nodes:</span>
<span class="sd">        ...         B.node[v].update(G.node[source])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is not idempotent in the sense that the node labels in</span>
<span class="sd">    the returned branching may be uniquely generated each time the</span>
<span class="sd">    function is invoked. In fact, the node labels may not be integers;</span>
<span class="sd">    in order to relabel the nodes to be more readable, you can use the</span>
<span class="sd">    :func:`networkx.convert_node_labels_to_integers` function.</span>

<span class="sd">    The current implementation of this function uses</span>
<span class="sd">    :func:`networkx.prefix_tree`, so it is subject to the limitations of</span>
<span class="sd">    that function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">has_cycle</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;dag_to_branching is only defined for acyclic graphs&#39;</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">HasACycle</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">root_to_leaf_paths</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">B</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">prefix_tree</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
    <span class="c1"># Remove the synthetic `root` and `NIL` nodes in the prefix tree.</span>
    <span class="n">B</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="n">B</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">NIL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">B</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2004-2018, NetworkX Developers.
      Last updated on Apr 25, 2018.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2rc1.dev20180425145258',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>