

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>networkx.algorithms.approximation.treewidth &mdash; NetworkX 2.2rc1.dev20180425145258 documentation</title>
  

  
  
  
  

  

  
  
    
      <link rel="search" type="application/opensearchdescription+xml"
            title="Search within NetworkX 2.2rc1.dev20180425145258 documentation"
            href="../../../../_static/opensearch.xml"/>
    

  

  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> NetworkX
          

          
          </a>

          
            
            
              <div class="version">
                2.2rc1.dev_20180425145258
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer/index.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../news.html">Release Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../auto_examples/index.html">Examples</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">NetworkX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>networkx.algorithms.approximation.treewidth</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for networkx.algorithms.approximation.treewidth</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Functions for computing treewidth decomposition.</span>
<span class="sd">   </span>
<span class="sd">   Treewidth of an undirected graph is a number associated with the graph. It can be defined as the size of the largest vertex set (bag) in a tree decomposition of the graph minus one. </span>

<span class="sd">`Wikipedia: Treewidth &lt;https://en.wikipedia.org/wiki/Treewidth&gt;`_</span>

<span class="sd">   The notions of treewidth and tree decomposition have gained their attractiveness partly because many graph and network problems that are intractable (e.g., NP-hard) on arbitrary graphs become efficiently solvable (e.g., with a linear time algorithm) when the treewidth of the input graphs is bounded by a constant [1]_ [2]_.</span>
<span class="sd">   </span>
<span class="sd">   There are two classes which contain implementations of different heuristics for computing tree decomposition: :class:`MinDegreeHeuristic` and :class:`MinFillInHeuristic`.</span>
<span class="sd">   </span>
<span class="sd">   :class:`MinDegreeHeuristic`</span>
<span class="sd">       Returns a treewidth decomposition using the Minimum Degree heuristic. The heuristic chooses the nodes according to their degree (number of neighours), i.e., first the node with the lowest degree is chosen, then the graph is updated and the correspondig node is removed. Next, a new node with the lowest degree is chosen, and so on.</span>
<span class="sd">   </span>
<span class="sd">        </span>
<span class="sd">   :class:`MinFillInHeuristic`</span>
<span class="sd">       Returns the node from the graph, where the number of edges added  when turning the neighbourhood of the chosen node into clique is as small as possible. This algorithm chooses the nodes using the Minimum Fill-In heuristic. The running time of the algorithm is :math:`O(V^3)` and it uses additional constant memory [3]_.</span>
<span class="sd">       </span>
<span class="sd">   </span>
<span class="sd">   .. [1] Hans L. Bodlaender and Arie M. C. A. Koster. 2010. &quot;Treewidth computations I.Upper bounds&quot;. Inf. Comput. 208, 3 (March 2010),259-275. http://dx.doi.org/10.1016/j.ic.2009.03.008</span>

<span class="sd">   .. [2] Hand L. Bodlaender. &quot;Discovering Treewidth&quot;. institute of information and computing sciences, utrecht university. technical report UU-CS-2005-018. http://www.cs.uu.nl</span>
<span class="sd">   </span>
<span class="sd">   .. [3] K. Wang, Z. Lu, and J. Hicks *Treewidth*. http://web.eecs.utk.edu/~cphillip/cs594_spring2015_projects/treewidth.pdf</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="k">import</span> <span class="n">not_implemented_for</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="k">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span><span class="p">,</span> <span class="n">heapify</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;treewidth_min_degree&quot;</span><span class="p">,</span> <span class="s2">&quot;treewidth_min_fill_in&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="treewidth_min_degree"><a class="viewcode-back" href="../../../../reference/algorithms/generated/networkx.algorithms.approximation.treewidth.treewidth_min_degree.html#networkx.algorithms.approximation.treewidth.treewidth_min_degree">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;directed&#39;</span><span class="p">)</span>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;multigraph&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">treewidth_min_degree</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a treewidth decomposition using the Minimum Degree heuristic. The heuristic chooses the nodes according to their degree, i.e., first the node with the lowest degree is chosen, then the graph is updated and the correspondig node is removed. Next, a new node with the lowest degree is chosen, and so on.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Treewidth decomposition : (int, Graph) tuple</span>
<span class="sd">          2-tuple with treewidth and the corresponding decomposed tree (NetworkX graph).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">treewidth_decomp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">MinDegreeHeuristic</span><span class="p">)</span></div>


<div class="viewcode-block" id="treewidth_min_fill_in"><a class="viewcode-back" href="../../../../reference/algorithms/generated/networkx.algorithms.approximation.treewidth.treewidth_min_fill_in.html#networkx.algorithms.approximation.treewidth.treewidth_min_fill_in">[docs]</a><span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;directed&#39;</span><span class="p">)</span>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s1">&#39;multigraph&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">treewidth_min_fill_in</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a treewidth decomposition using the Minimum Fill-in heuristic. The heuristic chooses a node from the graph, where the number of edges added  when</span>
<span class="sd">        turning the neighbourhood of the chosen node into clique is small as possible.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Treewidth decomposition : (int, Graph) tuple</span>
<span class="sd">        2-tuple with treewidth and the corresponding decomposed tree (NetworkX graph).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">treewidth_decomp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">MinFillInHeuristic</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">MinDegreeHeuristic</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span>

        <span class="c1"># A collection of nodes that have to be updated in the heap before each iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_nodes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># self._degreeq is heapq with 2-tuples (degree,node)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_degreeq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># build heap with initial degrees</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_degreeq</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">heapify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_degreeq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="MinDegreeHeuristic.next"><a class="viewcode-back" href="../../../../reference/algorithms/generated/networkx.algorithms.approximation.treewidth.MinDegreeHeuristic.next.html#networkx.algorithms.approximation.treewidth.MinDegreeHeuristic.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement next method for backwards compatibility with python 2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Update nodes in self._update_nodes</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_nodes</span><span class="p">:</span>
            <span class="c1"># insert changed degrees into degreeq</span>
            <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_degreeq</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span> <span class="n">n</span><span class="p">))</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degreeq</span><span class="p">:</span>
            <span class="c1"># get the next (minimum degree) node</span>
            <span class="p">(</span><span class="n">min_degree</span><span class="p">,</span> <span class="n">elim_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_degreeq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elim_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">[</span><span class="n">elim_node</span><span class="p">])</span> <span class="o">!=</span> <span class="n">min_degree</span><span class="p">:</span>
                <span class="c1"># Outdated entry in degreeq</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">min_degree</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Fully connected: Abort condition</span>
                <span class="k">raise</span> <span class="ne">StopIteration</span>

            <span class="c1"># Remember to update nodes in the heap before getting the next node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">[</span><span class="n">elim_node</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">elim_node</span>

        <span class="c1"># The heap is empty: Abort</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span>


<span class="k">class</span> <span class="nc">MinFillInHeuristic</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span> <span class="o">=</span> <span class="n">graph</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="MinFillInHeuristic.next"><a class="viewcode-back" href="../../../../reference/algorithms/generated/networkx.algorithms.approximation.treewidth.MinFillInHeuristic.next.html#networkx.algorithms.approximation.treewidth.MinFillInHeuristic.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement next method for backwards compatibility with python 2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="n">min_fill_in_node</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">min_fill_in</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>

        <span class="c1"># create sorted list of (degree, node)</span>
        <span class="n">degree_list</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">[</span><span class="n">node</span><span class="p">]),</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">]</span>
        <span class="n">degree_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># abort condition</span>
        <span class="n">min_degree</span> <span class="o">=</span> <span class="n">degree_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">min_degree</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="ow">in</span> <span class="n">degree_list</span><span class="p">:</span>
            <span class="n">num_fill_in</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Convert to list in order to access by index</span>
            <span class="n">nbrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nbrs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nbrs</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">nbrs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph</span><span class="p">[</span><span class="n">nbrs</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                        <span class="n">num_fill_in</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="c1"># break inner loop if this can&#39;t be min-fill-in node anymore</span>
                        <span class="k">if</span> <span class="n">num_fill_in</span> <span class="o">&gt;=</span> <span class="n">min_fill_in</span><span class="p">:</span>
                            <span class="k">break</span>

                <span class="k">if</span> <span class="n">num_fill_in</span> <span class="o">&gt;=</span> <span class="n">min_fill_in</span><span class="p">:</span> <span class="c1"># break outer loop</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">num_fill_in</span> <span class="o">&lt;</span> <span class="n">min_fill_in</span><span class="p">:</span> <span class="c1"># Update min-fill-in node</span>
                <span class="k">if</span> <span class="n">num_fill_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">node</span>
                <span class="n">min_fill_in</span> <span class="o">=</span> <span class="n">num_fill_in</span>
                <span class="n">min_fill_in_node</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">return</span> <span class="n">min_fill_in_node</span>


<div class="viewcode-block" id="treewidth_decomp"><a class="viewcode-back" href="../../../../reference/algorithms/generated/networkx.algorithms.approximation.treewidth.treewidth_decomp.html#networkx.algorithms.approximation.treewidth.treewidth_decomp">[docs]</a><span class="k">def</span> <span class="nf">treewidth_decomp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">heuristic_class</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a treewidth decomposition using the passed heuristic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">    heuristic_class : iterator class</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Treewidth decomposition : (int, Graph) tuple</span>
<span class="sd">        2-tuple with treewidth and the corresponding decomposed tree (NetworkX graph).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># make dict-of-sets structure</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>  <span class="c1"># ignore self-loop</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># stack where nodes and their neighbors are pushed in the order they are selected by the heuristic</span>
    <span class="n">node_stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># instantiate a heuristic_iterator</span>
    <span class="n">heuristic_iterator</span> <span class="o">=</span> <span class="n">heuristic_class</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">elim_node</span> <span class="ow">in</span> <span class="n">heuristic_iterator</span><span class="p">:</span>
        <span class="c1"># Connect all neighbours with each other</span>
        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">elim_node</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                    <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># push node and its current neighbors on stack</span>
        <span class="n">node_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">elim_node</span><span class="p">,</span> <span class="n">nbrs</span><span class="p">))</span>

        <span class="c1"># remove node from graph</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elim_node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">elim_node</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">graph</span><span class="p">[</span><span class="n">elim_node</span><span class="p">]</span>

    <span class="c1"># The abort condition is met. Put all nodes into one bag.</span>
    <span class="n">decomp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">first_bag</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">decomp</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">first_bag</span><span class="p">)</span>

    <span class="n">treewidth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_bag</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">node_stack</span><span class="p">:</span>
        <span class="c1"># get node and its neighbors from the stack</span>
        <span class="p">(</span><span class="n">curr_node</span><span class="p">,</span> <span class="n">nbrs</span><span class="p">)</span> <span class="o">=</span> <span class="n">node_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c1"># find a bag the neighbors are in</span>
        <span class="n">old_bag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">bag</span> <span class="ow">in</span> <span class="n">decomp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nbrs</span> <span class="o">&lt;=</span> <span class="n">bag</span><span class="p">:</span>
                <span class="n">old_bag</span> <span class="o">=</span> <span class="n">bag</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">old_bag</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no old_bag was found: just connect to the first_bag</span>
            <span class="n">old_bag</span> <span class="o">=</span> <span class="n">first_bag</span>

        <span class="c1"># Create new node for decomposition</span>
        <span class="n">nbrs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
        <span class="n">new_bag</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">nbrs</span><span class="p">)</span>

        <span class="c1"># Update treewidth</span>
        <span class="n">treewidth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">treewidth</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bag</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Add edge to decomposition (implicitly also adds the new node)</span>
        <span class="n">decomp</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">old_bag</span><span class="p">,</span> <span class="n">new_bag</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">treewidth</span><span class="p">,</span> <span class="n">decomp</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2004-2018, NetworkX Developers.
      Last updated on Apr 25, 2018.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'2.2rc1.dev20180425145258',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>